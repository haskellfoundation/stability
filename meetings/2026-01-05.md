---
tags: swg
---

SWG 2026-01-05
==============

Meeting URL: https://meet.jit.si/StableHaskellMeetBiWeekly

Previous meeting [notes](https://github.com/haskellfoundation/stability/blob/main/meetings/2025-12-08.md)

# Attendees

- Trevis Elser
- Jose Calderon
- Simon PJ


# In progress projects

- [hie library split](https://gitlab.haskell.org/jappeace/ghc/-/merge_requests/1)
  - https://gitlab.haskell.org/ghc/ghc/-/issues/18329
  - https://gitlab.haskell.org/ghc/ghc/-/issues/26505
      - https://gitlab.haskell.org/ghc/ghc/-/merge_requests/15024
  - https://gitlab.haskell.org/ghc/ghc-wiki-mirror/-/blob/master/hie-files.md
  - GHC produces a M.hie when you say `-fwrite-ide-info`
  - Consumers can read M.hie, and get a `HieAST`:
    ```
    data HieAST a =
       Node
         { sourcedNodeInfo :: SourcedNodeInfo a
         , nodeSpan :: Span
         , nodeChildren :: [HieAST a] }

    newtype SourcedNodeInfo a = SourcedNodeInfo {
        getSourcedNodeInfo :: (M.Map NodeOrigin (NodeInfo a)) }

    data NodeInfo a = NodeInfo
        { nodeAnnotations :: S.Set NodeAnnotation
        , nodeType :: [a]
        , nodeIdentifiers :: NodeIdentifiers a }

    type NodeIdentifiers a = M.Map Identifier (IdentifierDetails a)
    type Identifier = Either ModuleName Name
    data IdentifierDetails a = IdentifierDetails
      { identType :: Maybe a
      , identInfo :: S.Set ContextInfo }

    data ContextInfo
       = Use                -- ^ regular variable
       | MatchBind
       | IEThing IEType     -- ^ import/export
       | TyDecl

       -- | Value binding
       | ValBind
           BindType     -- ^ whether or not the binding is in an instance
           Scope        -- ^ scope over which the value is bound
           (Maybe Span) -- ^ span of entire binding

       | PatternBind
           Scope        -- ^ scope /in the pattern/ (the variable bound can be used
                        -- further in the pattern)
           Scope        -- ^ rest of the scope outside the pattern
           (Maybe Span) -- ^ span of entire binding

       | ClassTyDecl (Maybe Span)

       -- | Declaration
       | Decl
           DeclType     -- ^ type of declaration
           (Maybe Span) -- ^ span of entire binding

       -- | Type variable
       | TyVarBind Scope TyVarScope

       -- | Record field
       | RecField RecFieldContext (Maybe Span)

       -- | Constraint/Dictionary evidence variable binding
       | EvidenceVarBind
           EvVarSource  -- ^ how did this bind come into being
           Scope        -- ^ scope over which the value is bound
           (Maybe Span) -- ^ span of the binding site

       -- | Usage of evidence variable
       | EvidenceVarUse

    ```
   - **Goal**: make a more stable `HieAST` type, so tools can be cross-GHC compatible.
   - Clearly GHC's source AST varies between versions; so how *can* the HieAST be stable?  Perhaps it doesn't have all the info from the GHC source tree?
   - We are a bit lost...
   - Make the HieAST and related a library that ghc depends on
     - Naturally cannot have *all* info from GHC internal AST
     - Still allows tooling to build things like linters, dead code detection, etc
     - "Imperfect but practical"

- Trevis: Extension categorization
  - Preparing next proposal

- Jappie: Cabal exact-print proposal
  - Done! See [announcement](https://blog.haskell.org/a-comment-preserving-cabal-parser/)

- Ben/Andreas/GHC team: Reinstallable `base`
  - Working on blog post to describe project motivation and progress
  - Test suite being moved/decoupled
  - Shout about it more!  Release GHC 10.0 instead of 9.16

- Jose: Page listing community volunteers doing important work

# New items

- https://gitlab.haskell.org/ghc/ghc/-/issues/26711
  A _very_ bad look for our community to have this happen again

  How could testing release candidates be made easier?
  * Was the failing package in head.hackage?  Could it be?
  * Does head.hackage run the testsuite of each package?
  * Could we run a stackage smoke-test before patch-level release?  We compile head.hackage regularly; would it not be easy to compile stackage equally regularly?

- [Any stability ideas for summer of code](https://discourse.haskell.org/t/gsoc-2026-call-for-ideas/13479)
  - Is this even appropriate?
  - Removing GHC specifics out of base
  - Add a stackage smoke-test to ghc ci
  - Anything for reinstallable base that is appropriate here?
    - Ask Ben or Andreas
  - #26657 (sub-task of #26253) would be very useful, allowing more stuff to move from `ghc-internal` to `base`.

# Parked Action Items/Projects

# New for next meeting

## Action items

## Discussion items
